<!doctype html>
<html>
<head>
    <title>uav | simple is good.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css?family=Audiowide" rel="stylesheet">
</head>
<body>
<style type="text/css">
body {
    margin: 0;
    font-family: Georgia, serif;
    font-size: 16px;
    line-height: 1.7;
    color: #4c4c4c;
    background-color: #efefef;
    padding: 80px 10%;
}
h1, h2, h3 {
    font-family: 'Audiowide', sans-serif;
    text-transform: uppercase;
}
h1 {
    font-size: 70px;
    margin: 0;
    text-transform: none;
}
h2 {
    font-size: 20px;
}
h3 {
    font-size: 17px;
}
blockquote {
    padding: 0 20px;
    margin: 0;
    border: 1px solid gainsboro;
    border-left: 3px solid #ccc;
    background: #f3f3f3;
}
pre {
    background: #3a3a3a;
    padding: 20px 25px;
    color: #efefef;
    overflow-x: scroll;
    font-size: 14px;
    border: 1px solid black;
}
.center {
    text-align: center;
    margin-bottom: 25px;
}
code {
    word-break: break-word;
}
pre code {
    word-break: normal;
}
a {
    color: #4770c1;
    text-decoration: none;
}
</style>
<div class="center">
<h1>uav</h1>
<p>
<a href="https://github.com/unearth-inc/uav">github</a> | <a href="https://www.npmjs.com/package/uav">npm</a>
</p>
</div>
<p>uav aims to demonstrate that complexity is a problem in today's front end codebases. Think of it as an alternative to React, Vue, or Angular, but easier to use, and only 2KB compressed.</p>
<ul>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#creating-a-component">Creating a Component</a></li>
<li><a href="#template-expressions">Template Expressions</a>
<ul>
<li><a href="#text-expressions">Text Expressions</a></li>
<li><a href="#attribute-expressions">Attribute Expressions</a></li>
<li><a href="#boolean-attributes">Boolean Attributes</a></li>
<li><a href="#template-loops">Template Loops</a></li>
</ul>
</li>
<li><a href="#events">Events</a></li>
<li><a href="#child-components">Child Components</a></li>
<li><a href="#passing-data-to-children">Passing Data to Children</a></li>
<li><a href="#creating-a-model">Creating a Model</a></li>
<li><a href="#binding-html">Binding HTML</a></li>
<li><a href="#special-attributes">Special Attributes</a>
<ul>
<li><a href="#uav-src">uav-src</a></li>
<li><a href="#uav-style">uav-style</a></li>
</ul>
</li>
<li><a href="#dom-access">DOM Access</a></li>
<li><a href="#two-way-data-binding">Two Way Data Binding</a></li>
<li><a href="#performance-notes">Performance Notes</a></li>
<li><a href="#browser-compatibility">Browser Compatibility</a></li>
</ul>
<blockquote>
<p>The goal of uav is not adoption. The goal is to show that the problems faced by modern web apps are not complex enough to justify the millions of developer hours our industry has invested complicated frameworks.</p>
</blockquote>
<h2><a id="hello-world"></a>Hello World</h2>
<pre><code>const component = uav.component(
    { message: 'Hello, world!' }, 
    `&lt;h1&gt;{message}&lt;/h1&gt;`, 
    '#app'
);

// Renders into the #app element:
&lt;h1&gt;Hello, world!&lt;/h1&gt;

// After running the following ...
component.message = 'Goodbye, world.';

// ... the HTML automatically updates:
&lt;h1&gt;Goodbye, world.&lt;/h1&gt;
</code></pre>
<h2><a id="creating-a-component"></a>Creating a Component</h2>
<p><code>uav.component(model, template, selector, callback)</code></p>
<p>Arguments:</p>
<ul>
<li><code>model</code> (Object): A view model. Optional.</li>
<li><code>template</code> (String): An HTML template. Must have exactly one root node.</li>
<li><code>selector</code> (String|Element): The element in which to render the component. Optional.</li>
<li><code>callback</code> (Function): A function to call after the initial render. Passed the component's top-level DOM element. Optional.</li>
</ul>
<p>Returns the model.</p>
<p>Changes to existing properties on the model will trigger an optimized re-render. Only the smallest DOM change possible will occur, down to the level of updating a single element attribute or text node. This is accomplished without any DOM diffing, because uav constructs a tree of closures that know exactly what needs to be updated whenever a particular property is changed.</p>
<h2><a id="template-expressions"></a>Template Expressions</h2>
<p>By default, uav expressions use <code>{curly}</code> notation. Any browser-supported JavaScript can be used in an any expression. The result of the expression should be one of the following:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Function (for event handlers)</li>
<li>Boolean (for simplified class and property bindings)</li>
<li>DOM element (don't render untrusted HTML in templates)</li>
<li>uav component</li>
<li>undefined or null (renders an empty string)</li>
</ul>
<p>Regardless of what you are binding or where you are binding it, the syntax is always the same.</p>
<blockquote>
<p>You can change the template tag syntax with <code>uav.setTag()</code>. For example, to use <code>{{mustache}}</code> notation, call <code>uav.setTag('{{', '}}')</code> before creating any components.</p>
</blockquote>
<h3><a id="text-expressions"></a>Text Expressions:</h3>
<pre><code>uav.component(
    { content: 'foo' },
    `&lt;div&gt;This is a content expression: {content}&lt;/div&gt;`
);
</code></pre>
<h3><a id="attribute-expressions"></a>Attribute Expressions:</h3>
<pre><code>const component = uav.component({
    visible: true,
    className: 'component'
},
    `&lt;div class="{className} {visible}"&gt;&lt;/div&gt;`
);

// Renders the following:
&lt;div class="component visible"&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>If an expression evaluates to a boolean, it will render nothing if false, or the property name if true. This makes toggling the "visible" class on the above <code>&lt;div&gt;</code> as easy as <code>component.visble = !component.visible</code>.</p>
</blockquote>
<h3><a id="boolean-attributes"></a>Boolean Attributes</h3>
<pre><code>uav.component(
    { disabled: true },
    `&lt;input type="text" {disabled}&gt;`
);

// Renders:
&lt;input type="text" disabled&gt;
</code></pre>
<h3><a id="template-loops"></a>Template Loops</h3>
<p>Use the <code>uav-loop</code> and <code>uav-as</code> attributes to loop over an array as follows:</p>
<pre><code>uav.component({
    items: [ 1, 2, 'three' ]
}, `
    &lt;ul uav-loop="items" uav-as="item"&gt;
        &lt;li&gt;{item}&lt;/li&gt;
    &lt;/ul&gt;
`);
</code></pre>
<p>This component will render the following:</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>You can set a variable for the index of the current array item by adding a comma and a variable name to the <code>uav-as</code> attribute:</p>
<pre><code>uav.component({
    items: [ 1, 2, 'three' ]
}, `
    &lt;ul uav-loop="items" uav-as="item,index"&gt;
        &lt;li class="item-{index}"&gt;{item}&lt;/li&gt;
    &lt;/ul&gt;
`);
</code></pre>
<p>Renders:</p>
<pre><code>&lt;ul&gt;
    &lt;li class="item-0"&gt;1&lt;/li&gt;
    &lt;li class="item-1"&gt;2&lt;/li&gt;
    &lt;li class="item-2"&gt;three&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Things you may wonder about:</p>
<ul>
<li>Properties of the parent model are available within a loop.</li>
<li>Like a component, a loop's content must have one root node.</li>
<li>Array methods that modify the array like <code>push</code> and <code>splice</code> will trigger a re-render of the loop.</li>
<li>Curly braces are optional in the <code>uav-loop</code> and <code>uav-as</code> attributes, since we know the values will always be template expressions.</li>
</ul>
<h3><a id="events"></a>Events</h3>
<pre><code>uav.component(
    { click: e =&gt; console.log(e) }, 
    `&lt;button onclick="{click}"&gt;Click me&lt;/button&gt;`
);
</code></pre>
<p>Like any expression, you can pass data to an event handler:</p>
<pre><code>uav.component({
    click: item =&gt; e =&gt; console.log(item),
    items: [ 'foo', 'bar', 'baz' ]
}, `
    &lt;ul uav-loop="items" uav-as="item"&gt;
        &lt;li onclick="{click(item)}"&gt;This is {item}&lt;/li&gt;
    &lt;/ul&gt;
`)
</code></pre>
<h2><a id="child-components"></a>Child Components</h2>
<p>A component can be rendered into other components.</p>
<pre><code>const child = uav.component(`&lt;h3&gt;I am a child.&lt;/h3&gt;`);

uav.component(
    { child }, `
    &lt;div&gt;
        &lt;h1&gt;This is a component with a child.&lt;/h1&gt;
        {child}
    &lt;/div&gt;
`);
</code></pre>
<p>This will render the following:</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;This is a component with a child.&lt;/h1&gt;
    &lt;h3&gt;I am a child.&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<h3><a id="passing-data-to-children"></a>Passing Data to Children</h3>
<pre><code>const child = data =&gt; uav.component(
    { data }, 
    `&lt;em&gt;{data}&lt;/em&gt;`
);

uav.component({
    child: child('This is passed from parent to child.')
}, `
    &lt;div&gt;
        This component passes data to its child.
        {child}
    &lt;/div&gt;
`);
</code></pre>
<p>The parent component above passes data when the model is created. You could just as easily pass the data through the template:</p>
<pre><code>uav.component(
    { child }, 
    `&lt;div&gt;
        This component passes data to its child.
        {child('This is passed from parent to child.')}
    &lt;/div&gt;`
);
</code></pre>
<p>Either way, it will render the following:</p>
<pre><code>&lt;div&gt;
    This component passes data to its child.
    &lt;em&gt;This is passed from parent to child.&lt;/em&gt;
&lt;/div&gt;
</code></pre>
<p>uav supports swapping child components on the fly. For example, you could call <code>component.child = someOtherComponent</code> and the view will update accordingly. Just remember that uav is aggressive about avoiding memory leaks, and will remove any bindings that were attached to the original component before it was replaced.</p>
<h2><a id="creating-a-model"></a>Creating a Model</h2>
<p>If you want to create a view model before associating it with a template, use <code>uav.model</code>. It can come in handy when a model refers to itself at render time.</p>
<pre><code>const model = uav.model({
    active: true,
    isActive: () =&gt; model.active
});

const component = uav.component(model, '&lt;div class="item {isActive() ? 'active' : 'inactive'}"&gt;&lt;/div&gt;')
</code></pre>
<p>Note, however, that this can be a code smell. The above component could be more simply written without the <code>isActive</code> function:</p>
<pre><code>const component = uav.component(
    { active: true },
    '&lt;div class="item {active ? 'active' : 'inactive'}"&gt;&lt;/div&gt;'
);
</code></pre>
<p>A good dev will go further, knowing that it is unnecessary to define two different CSS classes describing boolean states:</p>
<pre><code>const component = uav.component(
    { active: true },
    '&lt;div class="item {active}"&gt;&lt;/div&gt;'
);
</code></pre>
<h3><a id="binding-html"></a>Binding HTML</h3>
<p>To render an HTML string as a DOM element, you can use <code>uav.parse()</code>.</p>
<pre><code>uav.component({
    html: uav.parse('&lt;script&gt;location="https://en.wikipedia.org/wiki/Cross-site_scripting"&lt;/script&gt;')
}, 
    `&lt;div&gt;{html}&lt;/div&gt;`
);
</code></pre>
<h2><a id="special-attributes"></a>Special Attributes</h2>
<h3><a id="uav-src"></a>uav-src</h3>
<p>Imagine that an image's source is bound to a template expression:</p>
<p><code>uav.component('&lt;img src="{imageSource}" /&gt;');</code></p>
<p>To prevent your browser from making a request to <code>/{imageSource}</code> before your JavaScript runs, you can use the <code>uav-src</code> attribute.</p>
<p><code>uav.component('&lt;img uav-src="{imageSource}" /&gt;');</code></p>
<h3><a id="uav-style"></a>uav-style</h3>
<p>Internet Explorer can be extremely picky about the value of an inline <code>style</code> tag. A template expression like the following will work in any browser except IE:</p>
<p><code>uav.component('&lt;div style="left: {left}px"&gt;&lt;/div&gt;');</code></p>
<p>To support Internet Explorer, you can use the <code>uav-style</code> attribute instead:</p>
<p><code>uav.component('&lt;div uav-style="left: {left}px"&gt;&lt;/div&gt;');</code></p>
<h2><a id="dom-access"></a>DOM Access</h2>
<p>Elements can be accessed directly by passing a selector to the <code>uav</code> or <code>uav.all</code> functions.</p>
<p>Access the first matched element:</p>
<p><code>uav('.item').classList.toggle('visible');</code></p>
<p>Run a callback on all matched elements:</p>
<p><code>uav('.item', item =&gt; item.classList.toggle('visible'));</code></p>
<p>Get an array of all matched elements:</p>
<p><code>uav.all('.item').forEach(item =&gt; item.classList.toggle('visible'));</code></p>
<h2><a id="two-way-data-binding"></a>Two Way Data Binding</h2>
<p>Two way binding is cool, but is only applicable to form interfaces, and can encourage lazy coding practices. Furthermore, it requires creating <code>oninput</code> event listeners behind the scenes, when often your use case only requires <code>change</code> or <code>submit</code> listeners. For these reasons it is included as a separate file, <code>uav-bind.js</code>.</p>
<p>After including this file, any HTML input types that support the <code>value</code> property can be two-way bound using the <code>uav-bind</code> attribute. When a user changes a value, the model will automatically update to reflect it.</p>
<pre><code>uav.component(
    { value: 'hi there' }
    `&lt;input type="text" uav-bind="value"/&gt;`
);
</code></pre>
<p>Because checkbox inputs describe a list of selected items, they can only be bound to arrays.</p>
<pre><code>uav.component({
    items: [1, 2]
}, `
    &lt;input type="checkbox" uav-bind="items" value="1" name="check"&gt;1&lt;br&gt;
    &lt;input type="checkbox" uav-bind="items" value="2" name="check"&gt;2&lt;br&gt;
    &lt;input type="checkbox" uav-bind="items" value="3" name="check"&gt;3&lt;br&gt;`
);
</code></pre>
<blockquote>
<p><code>uav-bind.js</code> is 0.5KB compressed.</p>
</blockquote>
<h2><a id="performance-notes"></a>Performance Notes</h2>
<h3><a id="only-bind-data-when-you-have-to"></a>Only bind data when you have to</h3>
<p>Avoid putting any data on the model that doesn't need to be bound to the DOM. If a particular value will never change, or changes to it don't need to update the DOM, just use a regular ES6 template variable to reference it (put a dollar sign in front of the expression).</p>
<pre><code>const wontChange = 'hi!';

uav.component({
    willChange: 'loading...'
}, `
    &lt;div&gt;
        &lt;p&gt;${wontChange}&lt;/p&gt;
        &lt;p&gt;{willChange}&lt;/p&gt;
    &lt;/div&gt;
`)
</code></pre>
<h3><a id="unbind-any-dom-nodes-youve-manually-detached"></a>Unbind any DOM nodes you've manually detached</h3>
<p>When uav updates the DOM as a result of a change to a model, it automatically removes any bindings to DOM nodes that have been removed or replaced. However, if for some reason you manually remove or replace a bound DOM node, you can clean up any bindings associated with it by calling <code>uav.unbind(&lt;Element&gt;)</code>. There is no harm in calling <code>uav.unbind</code> on an element that does not have any associated bindings.</p>
<h2><a id="collapsing-whitespace"></a>Collapsing Whitespace</h2>
<p>Using multiline template strings creates unnecessary whitespace in your JavaScript files. To collapse this whitespace, add a step like this to your build process:</p>
<p><code>tr -s " " &lt; dist/bundle.js &gt; dist/tmp &amp;&amp; mv dist/tmp dist/bundle.js</code></p>
<h2><a id="browser-compatibility"></a>Browser Compatibility</h2>
<p>IE9+</p>
<h2><a id="coming-soon"></a>Coming Soon</h2>
<ul>
<li>uav-router: The simplest possible routing solution for single page apps</li>
<li>uav-server: Render your uav apps from Node to make them search-engine friendly.</li>
</ul>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-106154554-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
